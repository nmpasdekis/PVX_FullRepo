{
	"Processes":[
		{
			"Shader": "#version 440\n\nlayout(binding = 0) uniform sampler2D PositionTex;\nlayout(binding = 1) uniform sampler2D ColorTex;\nlayout(binding = 2) uniform sampler2D NormalTex;\nlayout(binding = 3) uniform sampler2D MaterialTex;\n\nlayout(std140, binding = 0) uniform Camera{\n\tmat4 View;\n\tmat4 Projection;\n\tvec4 CameraPosition;\n};\n\nlayout(std140, binding = 1) uniform Lights{\n\tfloat Atten3;\n\tfloat Atten2;\n\tfloat Atten1;\n\tint LightCount;\n\tstruct {\n\t\tvec4 Position;\n\t\tvec4 Color;\n\t} Light[16];\n};\n\nin vec2 UV;\n\nout vec4 Color;\n\nconst float PI = 3.14159265359;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n\t//return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n\treturn F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n\tfloat a2 = roughness*roughness;\n\ta2 *= a2;\n\tfloat NdotH = max(dot(N, H), 0.0);\n\tfloat NdotH2 = NdotH * NdotH;\n\n\tfloat denom = (NdotH2 * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n\n\treturn a2 / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n\tfloat r = (roughness + 1.0);\n\tfloat k = (r*r) / 8.0;\n\n\tfloat num = NdotV;\n\tfloat denom = NdotV * (1.0 - k) + k;\n\n\treturn num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n\tfloat NdotV = max(dot(N, V), 0.0);\n\tfloat NdotL = max(dot(N, L), 0.0);\n\tfloat ggx2 = GeometrySchlickGGX(NdotV, roughness);\n\tfloat ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n\treturn ggx1 * ggx2;\n}\n\nvoid main() {\n\tvec4 Attenuation = vec4(Atten3, Atten2, Atten1, 1.0);\n\n\tivec2 txc = ivec2(gl_FragCoord.xy);\n\tvec3 n0 = texelFetch(NormalTex, txc, 0).xyz;\n\tvec3 albedo = texelFetch(ColorTex, txc, 0).xyz;\n\tvec4 Material = texelFetch(MaterialTex, txc, 0);\n\n\t//vec3 n0 = texture(NormalTex, UV).xyz;\n\t//vec3 albedo = texture(ColorTex, UV).xyz;\n\t//vec4 Material = texture(MaterialTex, UV);\n\n\tconst float metallic = Material.x;\n\tconst float roughness = Material.y;\n\tconst float ao = 1.0;\n\n\tif (dot(n0, n0)>0.01) {\n\t\tvec3 N = normalize(n0);\n\t\t//vec3 WorldPos = texture(PositionTex, UV).xyz;\n\t\tvec3 WorldPos = texelFetch(PositionTex, txc, 0).xyz;\n\n\t\tvec3 V = normalize(CameraPosition.xyz - WorldPos);\n\n\t\tvec3 F0 = mix(vec3(0.04), albedo, metallic);\n\n\t\t// reflectance equation\n\t\tvec3 Lo = vec3(0.0);\n\t\tfor (int i = 0; i < LightCount; i++) {\n\t\t\t// calculate per-light radiance\n\t\t\tvec3 L = -Light[i].Position.xyz;\n\t\t\tfloat attenuation = 1.0;\n\t\t\tif (Light[i].Position.w!=0) {\n\t\t\t\tL = Light[i].Position.xyz - WorldPos;\n\t\t\t\tfloat distance = length(Light[i].Position.xyz - WorldPos);\n\t\t\t\tattenuation = 1.0 / dot(Attenuation, vec4(distance * distance * distance, distance * distance, distance, 1.0));\n\t\t\t}\n\t\t\tL = normalize(L);\n\t\t\tvec3 H = normalize(V + L);\n\t\t\tvec3 radiance = Light[i].Color.xyz * attenuation;\n\n\t\t\t// cook-torrance brdf\n\t\t\tfloat NDF = DistributionGGX(N, H, 1-roughness);\n\t\t\tfloat G = GeometrySmith(N, V, L, 1-roughness);\n\t\t\tvec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n\n\t\t\tvec3 kS = F;\n\t\t\tvec3 kD = vec3(1.0) - kS;\n\t\t\tkD *= 1.0 - metallic;\n\n\t\t\tvec3 numerator = NDF * G * F;\n\t\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\t\tvec3 specular = numerator / max(denominator, 0.001);\n\n\t\t\t// add to outgoing radiance Lo\n\t\t\tfloat NdotL = max(dot(N, L), 0.0);\n\t\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t\t}\n\n\t\tvec3 ambient = vec3(0.03) * albedo * ao;\n\t\talbedo = ambient + Lo;\n\n\t\talbedo = albedo / (albedo + vec3(1.0));\n\t\talbedo = pow(albedo, vec3(1.0/2.2));\n\t}\n\tColor = vec4(albedo, 1.0);\n}",
			"Textures": [
				{ "Index": 0, "Name": "gPosition" },
				{ "Index": 1, "Name": "gAlbedo" },
				{ "Index": 2, "Name": "gNormal" },
				{ "Index": 3, "Name": "gMaterial" },
			]
		}
	]
}